import React from "react";
import { render } from "@testing-library/react";
import { describe, test, expect, vi, beforeEach, afterEach } from "vitest";
import ErrorBoundary from "../../../components/shared/ErrorBoundry";
import "@testing-library/jest-dom";

// Mock the ErrorInfo component
vi.mock("../../../components/shared/ErrorInfo", () => ({
  default: ({ message }: { message?: string }) => (
    <div data-testid="error-info">
      Error occurred: {message || "Default error message"}
    </div>
  ),
}));

// Component that throws an error for testing
const ThrowError = ({ shouldThrow }: { shouldThrow?: boolean }) => {
  if (shouldThrow) {
    throw new Error("Test error");
  }
  return <div>No error</div>;
};\n\n// Component that doesn't throw an error\nconst NoError = () => <div data-testid=\"no-error\">Working component</div>;\n\ndescribe(\"ErrorBoundary Component\", () => {\n  let consoleSpy: ReturnType<typeof vi.spyOn>;\n\n  beforeEach(() => {\n    // Suppress console.error in tests since we expect errors\n    consoleSpy = vi.spyOn(console, \"error\").mockImplementation(() => {});\n  });\n\n  afterEach(() => {\n    consoleSpy.mockRestore();\n  });\n\n  test(\"renders children when there is no error\", () => {\n    const { getByTestId } = render(\n      <ErrorBoundary>\n        <NoError />\n      </ErrorBoundary>\n    );\n    \n    expect(getByTestId(\"no-error\")).toBeInTheDocument();\n  });\n\n  test(\"renders ErrorInfo when child component throws an error\", () => {\n    const { getByTestId } = render(\n      <ErrorBoundary>\n        <ThrowError shouldThrow={true} />\n      </ErrorBoundary>\n    );\n    \n    expect(getByTestId(\"error-info\")).toBeInTheDocument();\n  });\n\n  test(\"renders ErrorInfo with custom message when error occurs\", () => {\n    const customMessage = \"Custom error boundary message\";\n    const { getByText } = render(\n      <ErrorBoundary message={customMessage}>\n        <ThrowError shouldThrow={true} />\n      </ErrorBoundary>\n    );\n    \n    expect(getByText(`Error occurred: ${customMessage}`)).toBeInTheDocument();\n  });\n\n  test(\"does not render ErrorInfo when fallback is false\", () => {\n    const { container } = render(\n      <ErrorBoundary fallback={false}>\n        <ThrowError shouldThrow={true} />\n      </ErrorBoundary>\n    );\n    \n    // When fallback is false and error occurs, nothing should render\n    expect(container).toBeEmptyDOMElement();\n  });\n\n  test(\"calls onCatch callback when error occurs\", () => {\n    const mockOnCatch = vi.fn();\n    \n    render(\n      <ErrorBoundary onCatch={mockOnCatch}>\n        <ThrowError shouldThrow={true} />\n      </ErrorBoundary>\n    );\n    \n    expect(mockOnCatch).toHaveBeenCalledOnce();\n  });\n\n  test(\"does not call onCatch when no error occurs\", () => {\n    const mockOnCatch = vi.fn();\n    \n    render(\n      <ErrorBoundary onCatch={mockOnCatch}>\n        <NoError />\n      </ErrorBoundary>\n    );\n    \n    expect(mockOnCatch).not.toHaveBeenCalled();\n  });\n\n  test(\"updates state when componentDidCatch is called\", () => {\n    const { getByTestId } = render(\n      <ErrorBoundary>\n        <ThrowError shouldThrow={true} />\n      </ErrorBoundary>\n    );\n    \n    // After error is thrown, ErrorInfo should be rendered\n    expect(getByTestId(\"error-info\")).toBeInTheDocument();\n  });\n\n  test(\"renders children normally before error occurs\", () => {\n    const { getByText, rerender } = render(\n      <ErrorBoundary>\n        <ThrowError shouldThrow={false} />\n      </ErrorBoundary>\n    );\n    \n    expect(getByText(\"No error\")).toBeInTheDocument();\n    \n    // Now trigger an error\n    rerender(\n      <ErrorBoundary>\n        <ThrowError shouldThrow={true} />\n      </ErrorBoundary>\n    );\n    \n    expect(getByText(\"Error occurred: Default error message\")).toBeInTheDocument();\n  });\n\n  test(\"uses default fallback value when not provided\", () => {\n    const { getByTestId } = render(\n      <ErrorBoundary>\n        <ThrowError shouldThrow={true} />\n      </ErrorBoundary>\n    );\n    \n    // Default fallback should be true, so ErrorInfo should render\n    expect(getByTestId(\"error-info\")).toBeInTheDocument();\n  });\n\n  test(\"handles multiple children\", () => {\n    const { getByText } = render(\n      <ErrorBoundary>\n        <div>Child 1</div>\n        <div>Child 2</div>\n        <NoError />\n      </ErrorBoundary>\n    );\n    \n    expect(getByText(\"Child 1\")).toBeInTheDocument();\n    expect(getByText(\"Child 2\")).toBeInTheDocument();\n    expect(getByTestId(\"no-error\")).toBeInTheDocument();\n  });\n\n  test(\"maintains error state after error is caught\", () => {\n    const { getByTestId, rerender } = render(\n      <ErrorBoundary>\n        <ThrowError shouldThrow={true} />\n      </ErrorBoundary>\n    );\n    \n    expect(getByTestId(\"error-info\")).toBeInTheDocument();\n    \n    // Re-render with non-throwing component, but error state should persist\n    rerender(\n      <ErrorBoundary>\n        <NoError />\n      </ErrorBoundary>\n    );\n    \n    // Error boundary should still show error info because state is maintained\n    expect(getByTestId(\"error-info\")).toBeInTheDocument();\n  });\n});